{"pageProps":{"posts":[{"slug":"03_mech_interp","content":"\n## Starting my Mech Interp Journey\n\nChange is never easy, and stepping away from astronomy after many years feels like giving up part of my identity. I don't regret my decision to pursue graduate school, those years have been nothing but fulfilling. It's a great privilege to dedicate time and effort to a pursuit of such intellectual purity. However, at the end of graduate school, one must once again cast thoughts toward the future.\nRemaining on the academic path brings uncertainty in many areas of life and often demands personal sacrifices: constant relocation, distance from loved ones, evolving responsibilities as teaching loads and funding pressures mount. Balancing these demands with other personal priorities is far from easy, and I found myself unable to envision navigating this path happily. I've also always been acutely aware that while astronomy is fascinating, there are infinite equally interesting areas of study and work—many of more immediate relevance to humanity.\nWhile changing trajectory has been difficult, deciding what to do next has been even more challenging. One area I'm strongly interested in pursuing is mechanistic interpretability.\n\n## The Rise of Neural Networks\n\nOver the years, I've observed the explosion of machine learning, or more accurately, the rise of neural networks, deep learning, and large language models as they evolved from esoteric topics to universal adoption, taking root in all aspects of society. The social implications are tremendous, and it really does appear to be a watershed moment in how humans interact with technology.\nYet so much remains mysterious about how these networks actually work. We train these systems on vast amounts of data, but their resultant capabilities have repeatedly exceeded expectations while theoretical understanding struggles to catch up. This reminds me of complex systems that display emergent behavior even with simple, local rule-based evolution. We know the full state of a trained neural network (every weight, bias, and computation that flows through it), but its overall capabilities still baffle us.\nInformation is being processed in ways that seem opaque to us, so a field has crystallized around making sense of this opacity in ways we can understand and interpret. This is mechanistic interpretability (or \"mech interp\"), the science of understanding how machine learning networks learn to process information, much like neuroscience tries to understand how the biological brain does something similar.\nWhile young, this field is moving at lightning speed. I strongly believe that progress in mech interp is among the most important research being done today, given the reach and rate of growth of this technology. Preventing these systems from pursuing unintended goals (known as AI alignment) surely requires developing an understanding of how these networks do what they do.\n\n## A New Experience\n\nWhile I've maintained interest in machine learning and neural networks over the years, my direct experience has been limited. The applications to my research were never convincing or promising enough (a lack of interpretability makes neural networks problematic for theoretical applications).\nRecently, however, I experimented with using Neural ODEs as a natural way of extending our usual process of modeling physical systems with differential equations through deep learning, while exploring symbolic regression to improve interpretability and generalizability. I also attended NeurIPS 2024 and got a feel for what the field was excited about, including in the context of scientific applications.\nIt's been over half a year since then, and many of the big ideas such as MCP, multimodal inputs, and agentic AI have dominated advances in that time. Along the way, I've repeatedly encountered work being done on mechanistic interpretability, including papers from the Anthropic team. Beyond skimming these papers, I haven't devoted time to thinking more deeply about these ideas.\nGiven that this is a field I'm interested in pursuing, I've decided to invest time in diving deeper into the ideas and research in the literature, and exploring where I might be able to contribute.\n\n## Why This Blog\n\nStarting this research blog serves three purposes.\n1. Mainly, I hope it will document my thoughts and ideas as they change and evolve while I learn and explore this new field. As I progress, it will be useful to return to earlier thoughts.\n2. Second, I want to improve the clarity of my writing, since I often find it difficult to express thoughts without extensive refinement.\n3. Finally, I'm hoping this imposes some level of self-accountability to keep at it regularly, since this will be on the side and doesn't overlap with my current work.","title":"Mech Interp Day 0: Motivations","date":"2025-07-09","excerpt":"Starting my mech interp journey","tags":["mech interp"]},{"slug":"02_animation","content":"\nThe previous iteration of this website featured an interactive 3D pulsating sphere built using Three.js. For the sake of a cleaner feel, I decided to remove it for this iteration, but found the experience rewarding. The animation I originally had can be found at the botto of this post! The capability for 3D graphics that Three.js provide is rich in potential, especially since modern web development has evolved far beyond static pages. Today's users expect rich, interactive experiences that feel more like native applications than traditional websites.\n\n## The Technology Stack\n\nCombining several powerful technologies can create truly engaging web experiences. The combination I initially went with included:\n\n- **Three.js** for 3D graphics and WebGL rendering\n- **Framer Motion** for smooth animations and transitions\n- **React** for component-based architecture\n- **Next.js** for performance optimization\n\n## Why 3D on the Web?\n\nThree.js has revolutionized how we think about web interfaces. Here's a simple example of creating a rotating cube:\n\n```javascript\nimport * as THREE from 'three';\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\n\nconst geometry = new THREE.BoxGeometry();\nconst material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\nconst cube = new THREE.Mesh(geometry, material);\n\nscene.add(cube);\ncamera.position.z = 5;\n\nfunction animate() {\n    requestAnimationFrame(animate);\n    cube.rotation.x += 0.01;\n    cube.rotation.y += 0.01;\n    renderer.render(scene, camera);\n}\n\nanimate();\n```\n\n## Animation with Framer Motion\n\nFramer Motion makes it incredibly easy to add smooth animations to React components:\n\n```jsx\nimport { motion } from 'framer-motion';\n\nconst AnimatedCard = () => {\n  return (\n    \n      Interactive Card\n      This card animates on load and hover!\n    \n  );\n};\n```\n\n## My Experience\n\nThe combination of Three.js and Framer Motion in a React/Next.js environment provides an incredibly powerful toolkit for creating memorable web experiences. The key is finding the right balance between visual impact and performance. The rest of this post will go through how I set up my initial animation, with the final product at the end!\n\n## Uniform Sampling of Points on A Sphere\n\nThe key to creating a convincing sphere lies in proper point distribution. Unlike naive approaches that create clustering at poles, we use **spherical coordinates** with uniform random sampling:\n\n```javascript\nconst points = [];\nfor (var i = 0; i < 1500; i++) {\n  var vertex = new THREE.Vector3();\n\n  // Uniform random sampling on sphere surface\n  var u = THREE.MathUtils.randFloat(0, 1);\n  var v = THREE.MathUtils.randFloat(0, 1);\n  var theta = 2 * Math.PI * u;           // Azimuthal angle\n  var phi = Math.acos(2 * v - 1);        // Polar angle\n\n  // Convert to Cartesian coordinates\n  vertex.x = 3.5 * Math.sin(phi) * Math.cos(theta);\n  vertex.y = 3.5 * Math.sin(phi) * Math.sin(theta);\n  vertex.z = 3.5 * Math.cos(phi);\n\n  points.push(vertex);\n}\n```\n\nThis approach ensures **uniform distribution** across the sphere surface, avoiding the visual artifacts of simpler random placement methods.\n\n## GLSL Shader\n\nThe pulsating light effect is achieved through custom **vertex and fragment shaders** that run directly on the GPU:\n\n### Shader Uniforms Setup\n\n```javascript\nconst shaderPoint = THREE.ShaderLib.points;\nconst uniforms = THREE.UniformsUtils.clone(shaderPoint.uniforms);\nuniforms.time = { value: 0 };\nuniforms.color = { type: \"v3\", value: colorValue };\n\nconst pMaterial = new THREE.ShaderMaterial({\n  uniforms,\n  transparent: true,\n  depthWrite: false,\n  blending: THREE.AdditiveBlending,  // Creates light emission effect\n  vertexShader,\n  fragmentShader,\n});\n```\n\n### The Shader Pipeline\n\nThis particle system consists of two interconnected shaders:\n\n- **Vertex Shader** (\"vert.glsl\") - Handles particle positioning, sizing, and movement\n- **Fragment Shader** (\"frag.glsl\") - Controls particle appearance, color, and glow effects\n\n### 3D Simplex Noise Implementation\n\nThe vertex shader begins with a complete **Simplex noise** implementation - a sophisticated algorithm for generating natural-looking randomness:\n\n```glsl\nfloat snoise(vec3 v) {\n    // 85 lines of math\n    // Creates smooth, continuous 3D noise\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n```\n\n**Why Simplex Noise?** Unlike basic random functions, Simplex noise provides:\n- **Continuous gradients** - no sudden jumps or artifacts\n- **3D coherence** - neighboring points have similar values\n- **Performance optimization** - faster than Perlin noise\n- **Natural patterns** - mimics organic movement and growth\n\n### Organic Particle Movement\n\nThe main vertex shader transforms each particle's position using time-based trigonometric functions:\n\n```glsl\nvec3 newPos = position;\n\nnewPos.x += sin(time + position.x * position.y) * 0.08;\nnewPos.y += cos(time + position.x * position.y * 1.1) * 0.08;\nnewPos.z += cos(time + position.x * position.y * 1.3) * 0.08;\n```\n\n**Mathematical Breakdown:**\n- **Base oscillation**: \"sin(time)\" and \"cos(time)\" create rhythmic movement\n- **Position coupling**: \"position.x * position.y\" makes each particle's movement unique\n- **Frequency variation**: Multipliers prevent synchronized motion\n- **Amplitude control**: \"0.08\" keeps movement subtle and elegant\n\nThis creates a **Lissajous-like pattern** where each particle follows its own complex orbital path, determined by its starting position.\n\n### Dynamic Particle Sizing\n\nThe most sophisticated aspect is the noise-driven size variation:\n\n```glsl\ngl_PointSize = 50. + snoise(position * 0.05 + vec3(0, 0, vtime * 0.1)) * 50.;\ngl_PointSize *= 0.5;\n```\n\n**Size Calculation Explained:**\n- **Base size**: \"50.\" pixels provides consistent minimum visibility\n- **Noise sampling**: \"snoise(position * 0.05 + ...)\" creates spatial variation\n- **Temporal drift**: \"vec3(0, 0, vtime * 0.1)\" makes noise evolve over time\n- **Amplitude**: \"* 50.\" allows sizes to range from 0 to 100 pixels\n- **Final scaling**: \"* 0.5\" reduces overall scale to 0-50 pixels\n\nThe result is particles that **breathe** - growing and shrinking organically as the noise field evolves through time.\n\n### Time-Based Animation\n\nThe pulsating effect is driven by a time uniform that updates every frame:\n\n```javascript\nconst animate = (time) => {\n  // Update shader time for pulsating effect\n  pMaterial.uniforms.time.value = time * 0.004;\n  \n  // Continue animation loop\n  requestAnimationFrame(animate);\n  renderer.render(scene, camera);\n}\n```\n\nThe **AdditiveBlending** mode creates the characteristic light emission, making particles appear to glow and blend naturally when they overlap.\n\n## Responsive Color System\n\nThe particle system adapts to the user's color mode preference through dynamic uniform updates:\n\n```javascript\n// Real-time color mode detection and adaptation\nif (localStorage.getItem(\"chakra-ui-color-mode\") === \"dark\") {\n  pMaterial.uniforms.color.value = new THREE.Color(0xffffff);  // White particles\n} else {\n  pMaterial.uniforms.color.value = new THREE.Color(0x000000);  // Black particles\n}\n```\n\nThis creates a seamless experience where the 3D scene automatically adapts to the user's interface preferences without requiring page refreshes.\n\n## Smooth Camera Animations\n\nThe initial camera movement uses an **easing function** to create natural motion:\n\n```javascript\nfunction easeOutCirc(x) {\n  return Math.sqrt(1 - Math.pow(x - 1, 4));\n}\n\n// Camera animation during first 100 frames\nif (frame <= 100) {\n  const rotSpeed = -easeOutCirc(frame / 120) * Math.PI * 20;\n  \n  camera.position.x = p.x * Math.cos(rotSpeed) + p.z * Math.sin(rotSpeed);\n  camera.position.z = p.z * Math.cos(rotSpeed) - p.x * Math.sin(rotSpeed);\n  camera.lookAt(target);\n} else {\n  // Switch to user-controlled orbit after animation\n  controls.update();\n}\n```\n\nAfter the initial animation completes, control transitions to **OrbitControls** for user interaction, with automatic rotation enabled.\n\n## Performance Optimizations\n\n### GPU-Accelerated Rendering\n- **ShaderMaterial** for GPU-based calculations\n\n### Efficient Animation Loop\n```javascript\nlet req = null;\nconst animate = (time) => {\n  req = requestAnimationFrame(animate);\n  \n  // Minimal CPU calculations\n  // GPU handles particle transformations\n  \n  renderer.render(scene, camera);\n}\n\n// Proper cleanup\nreturn () => {\n  cancelAnimationFrame(req);\n  renderer.domElement.remove();\n  renderer.dispose();\n}\n```\n\n## Final Product\nHere is the final animation, best viewed in dark mode!\n<hr />\n<voxel-art />","title":"Building Interactive Web Experiences","date":"2025-07-08","excerpt":"Exploring the combination of Three.js, Framer Motion, and React for creating engaging user interfaces","tags":["threejs","framer-motion","webgl","animation"]},{"slug":"01_implementation","content":"\nThis document summarizes the complete implementation of a markdown-based blog system using Next.js, Chakra UI, react-markdown, and KaTeX for mathematical equations.\n\n## Tech Stack\n\n- **Next.js** - React framework with static site generation\n- **Chakra UI** - Component library for styling\n- **react-markdown** - Markdown to React component converter\n- **KaTeX** - LaTeX equation rendering\n- **gray-matter** - Frontmatter parsing\n- **Framer Motion** - Animations\n\n## Required Dependencies\n\n```bash\nnpm install react-markdown remark-gfm rehype-highlight rehype-raw gray-matter katex rehype-katex remark-math\n```\n\n## File Structure\n\n```\nproject/\n├── components/\n│   └── BlogPost.jsx\n├── lib/\n│   └── posts.js\n├── pages/\n│   ├── writing.js (blog index)\n│   └── blog/\n│       └── [slug].js (individual posts)\n├── posts/\n│   ├── my-first-post.md\n│   └── second-blog-post.md\n└── pages/_app.js\n```\n\n## Core Components\n\n### lib/posts.js - File System Functions\n```javascript\nimport fs from 'fs';\nimport path from 'path';\nimport matter from 'gray-matter';\n\nconst postsDirectory = path.join(process.cwd(), 'posts');\n\nexport function getAllPosts() {\n  const fileNames = fs.readdirSync(postsDirectory);\n  const allPostsData = fileNames.map((fileName) => {\n    const slug = fileName.replace(/\\.md$/, '');\n    const fullPath = path.join(postsDirectory, fileName);\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n    const { data, content } = matter(fileContents);\n\n    return {\n      slug,\n      content,\n      ...data,\n    };\n  });\n\n  return allPostsData.sort((a, b) => (a.date < b.date ? 1 : -1));\n}\n\nexport function getPostBySlug(slug) {\n  const fullPath = path.join(postsDirectory, `${slug}.md`);\n  const fileContents = fs.readFileSync(fullPath, 'utf8');\n  const { data, content } = matter(fileContents);\n\n  return {\n    slug,\n    content,\n    ...data,\n  };\n}\n```\n\n### components/BlogPost.jsx - Markdown Renderer\n```javascript\nimport ReactMarkdown from 'react-markdown';\nimport remarkGfm from 'remark-gfm';\nimport remarkMath from 'remark-math';\nimport rehypeHighlight from 'rehype-highlight';\nimport rehypeKatex from 'rehype-katex';\nimport { \n  Box, \n  Heading, \n  Text, \n  Code, \n  Divider, \n  Link,\n  UnorderedList,\n  OrderedList,\n  ListItem,\n  useColorModeValue\n} from '@chakra-ui/react';\n\nconst BlogPost = ({ content }) => {\n  const blockquoteBg = useColorModeValue('gray.50', 'gray.700');\n  const inlineCodeBg = useColorModeValue('gray.100', 'gray.600');\n  const inlineCodeColor = useColorModeValue('gray.800', 'gray.100');\n\n  return (\n    <Box maxW=\"800px\" mx=\"auto\" p={6}>\n      <ReactMarkdown\n        remarkPlugins={[remarkGfm, remarkMath]}\n        rehypePlugins={[rehypeHighlight, rehypeKatex]}\n        components={{\n          h1: ({ children }) => (\n            <Heading as=\"h1\" size=\"2xl\" mb={6} mt={8}>\n              {children}\n            </Heading>\n          ),\n          h2: ({ children }) => (\n            <Heading as=\"h2\" size=\"xl\" mb={4} mt={6}>\n              {children}\n            </Heading>\n          ),\n          h3: ({ children }) => (\n            <Heading as=\"h3\" size=\"lg\" mb={3} mt={5}>\n              {children}\n            </Heading>\n          ),\n          p: ({ children }) => (\n            <Text mb={4} lineHeight=\"1.7\">\n              {children}\n            </Text>\n          ),\n          ul: ({ children }) => (\n            <UnorderedList mb={4} spacing={2}>\n              {children}\n            </UnorderedList>\n          ),\n          ol: ({ children }) => (\n            <OrderedList mb={4} spacing={2}>\n              {children}\n            </OrderedList>\n          ),\n          li: ({ children }) => (\n            <ListItem>{children}</ListItem>\n          ),\n          code: ({ inline, children, className }) => {\n            return inline ? (\n              <Code \n                px={2} \n                py={1} \n                bg={inlineCodeBg}\n                color={inlineCodeColor}\n                borderRadius=\"md\"\n                suppressHydrationWarning={true}\n              >\n                {children}\n              </Code>\n            ) : (\n              <Box mb={4}>\n                <Code\n                  as=\"pre\"\n                  display=\"block\"\n                  p={4}\n                  bg=\"gray.900\"\n                  color=\"white\"\n                  _dark={{ bg: \"gray.800\" }}\n                  borderRadius=\"md\"\n                  overflow=\"auto\"\n                  suppressHydrationWarning={true}\n                >\n                  {children}\n                </Code>\n              </Box>\n            );\n          },\n          a: ({ href, children }) => (\n            <Link href={href} color=\"blue.500\" isExternal>\n              {children}\n            </Link>\n          ),\n          blockquote: ({ children }) => (\n            <Box\n              as=\"blockquote\"\n              borderLeft=\"4px solid\"\n              borderColor=\"blue.500\"\n              pl={4}\n              py={2}\n              mb={4}\n              fontStyle=\"italic\"\n              bg={blockquoteBg}\n              _dark={{ bg: \"gray.700\", borderColor: \"blue.300\" }}\n              borderRadius=\"md\"\n              suppressHydrationWarning={true}\n            >\n              {children}\n            </Box>\n          ),\n          hr: () => <Divider my={6} />,\n        }}\n      >\n        {content}\n      </ReactMarkdown>\n    </Box>\n  );\n};\n\nexport default BlogPost;\n```\n\n### pages/writing.js - Blog Index\n```javascript\nimport NextLink from 'next/link'\nimport { Box, Container, Heading, Link, Text } from '@chakra-ui/react'\nimport Layout from '../components/layouts/article'\nimport Section from '../components/section'\nimport { getAllPosts } from '../lib/posts'\n\nconst Writing = ({ posts = [] }) => {\n  return (\n    <Layout title=\"Posts\">\n      <Container>\n        <Heading as=\"h3\" fontSize={20} mb={4} mt={5}>\n          Posts\n        </Heading>\n\n        {posts && posts.map((post, index) => (\n          <Section key={post.slug} delay={0.1 + (index + 1) * 0.1}>\n            <Box my={4}>\n              <Text fontSize=\"sm\" color=\"gray.500\" display=\"inline\" mr={3}>\n                {new Date(post.date + 'T00:00:00').toLocaleDateString('en-US', {\n                  year: 'numeric',\n                  month: 'short',\n                  day: 'numeric',\n                  timeZone: 'UTC'\n                })}\n              </Text>\n              <Link as={NextLink} href={`/blog/${post.slug}`}>\n                {post.title}\n              </Link>\n            </Box>\n          </Section>\n        ))}\n\n      </Container>\n    </Layout>\n  )\n}\n\nexport async function getStaticProps() {\n  try {\n    const posts = getAllPosts();\n    return {\n      props: {\n        posts,\n      },\n    };\n  } catch (error) {\n    console.error('Error in getStaticProps:', error);\n    return {\n      props: {\n        posts: [],\n      },\n    };\n  }\n}\n\nexport default Writing\n```\n\n### pages/blog/[slug].js - Individual Post Pages\n```javascript\nimport { getAllPosts, getPostBySlug } from '../../lib/posts';\nimport BlogPost from '../../components/BlogPost';\nimport { Box, Heading, Text } from '@chakra-ui/react';\n\nexport default function Post({ post }) {\n  return (\n    <Box>\n      <Box textAlign=\"center\" mb={8}>\n        <Heading as=\"h1\" size=\"3xl\" mb={4}>\n          {post.title}\n        </Heading>\n        <Text color=\"gray.600\">{post.date}</Text>\n      </Box>\n      <BlogPost content={post.content} />\n    </Box>\n  );\n}\n\nexport async function getStaticProps({ params }) {\n  const post = getPostBySlug(params.slug);\n  return {\n    props: {\n      post,\n    },\n  };\n}\n\nexport async function getStaticPaths() {\n  const posts = getAllPosts();\n  const paths = posts.map((post) => ({\n    params: { slug: post.slug },\n  }));\n\n  return {\n    paths,\n    fallback: false,\n  };\n}\n```\n\n## Markdown Features Supported\n\n### Basic Formatting\n- **Bold text** and *italic text*\n- Headers (H1, H2, H3)\n- Paragraphs with proper spacing\n- Horizontal rules\n- Links (internal and external)\n\n### Lists\n- Unordered lists with bullet points\n- Ordered lists with numbers\n- Proper spacing between items\n\n### Code\n- Multi-line code blocks with language-specific highlighting\n- Dark/light mode responsive styling\n\n### Blockquotes\n> Styled blockquotes with left border. Dark/light mode responsive\n\n### Mathematical Equations\n- Inline math: $E = mc^2$\n- Block equations: $$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$\n- Complex expressions with proper LaTeX rendering\n\n## Frontmatter Structure\n```yaml\n---\ntitle: \"Post Title\"\ndate: \"2025-01-15\"\nexcerpt: \"Brief description of the post\"\ntags: [\"tag1\", \"tag2\", \"tag3\"]\n---\n```\n\n## Development Workflow\n\n1. Create markdown files in posts/ directory\n2. Posts automatically appear on /writing page\n\n## Troubleshooting Notes\n\n- **Date Issues**: Use `new Date(post.date + 'T00:00:00')` to prevent timezone shifts\n- Inline equations not working","title":"Blog Implementation Summary","date":"2025-07-07","excerpt":"Complete guide to implementing a markdown blog with Next.js, Chakra UI, and mathematical equations","tags":["nextjs","react-markdown","chakra-ui","katex","blog"]},{"slug":"00_hello_world","content":"\n## Welcome to My Blog\n\nThis is my first blog post! I will just test functionality in this post, and write up how I implemented post functionality in a future post.\n\n## Code Example\n\n```python\ndef hello_world():\n    print(\"Hello, World!\")\n    return True\n``` \n\n## More Examples\n\n> This is a blockquote with some important information.\n\nCheck out [this link](https://example.com) for more info.\n\nHere's some **bold text** and *italic text*.\n\n### Lists\n\nUnordered list:\n- Item 1\n- Item 2\n- Item 3\n\nOrdered list:\n1. First item\n2. Second item\n3. Third item \n\n### Equations\nThis is an inline equation: $E = mc^2$.\n\nIn web animations, we often use trigonometric functions. The general form of a sine wave is:\n\n$$\ny(x,t) = A \\sin(kx - \\omega t + \\phi)\n$$\n\nWhere:\n- $A$ is the amplitude\n- $k$ is the wave number  \n- $\\omega$ is the angular frequency\n- $\\phi$ is the phase shift\n\nThis equation is perfect for creating smooth, natural animations in Three.js!\n\nThat's all for now!\n","title":"Hello World","date":"2025-07-06","excerpt":"This is my first blog post using react-markdown","tags":["react","nextjs","markdown"]}]},"__N_SSG":true}