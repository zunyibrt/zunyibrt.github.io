{"pageProps":{"post":{"slug":"02_animation","content":"\nThe previous iteration of this website featured an interactive 3D pulsating sphere built using Three.js. For the sake of a cleaner feel, I decided to remove it for this iteration, but found the experience rewarding. The animation I originally had can be found at the botto of this post! The capability for 3D graphics that Three.js provide is rich in potential, especially since modern web development has evolved far beyond static pages. Today's users expect rich, interactive experiences that feel more like native applications than traditional websites.\n\n## The Technology Stack\n\nCombining several powerful technologies can create truly engaging web experiences. The combination I initially went with included:\n\n- **Three.js** for 3D graphics and WebGL rendering\n- **Framer Motion** for smooth animations and transitions\n- **React** for component-based architecture\n- **Next.js** for performance optimization\n\n## Why 3D on the Web?\n\nThree.js has revolutionized how we think about web interfaces. Here's a simple example of creating a rotating cube:\n\n```javascript\nimport * as THREE from 'three';\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\n\nconst geometry = new THREE.BoxGeometry();\nconst material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\nconst cube = new THREE.Mesh(geometry, material);\n\nscene.add(cube);\ncamera.position.z = 5;\n\nfunction animate() {\n    requestAnimationFrame(animate);\n    cube.rotation.x += 0.01;\n    cube.rotation.y += 0.01;\n    renderer.render(scene, camera);\n}\n\nanimate();\n```\n\n## Animation with Framer Motion\n\nFramer Motion makes it incredibly easy to add smooth animations to React components:\n\n```jsx\nimport { motion } from 'framer-motion';\n\nconst AnimatedCard = () => {\n  return (\n    \n      Interactive Card\n      This card animates on load and hover!\n    \n  );\n};\n```\n\n## My Experience\n\nThe combination of Three.js and Framer Motion in a React/Next.js environment provides an incredibly powerful toolkit for creating memorable web experiences. The key is finding the right balance between visual impact and performance. The rest of this post will go through how I set up my initial animation, with the final product at the end!\n\n## Uniform Sampling of Points on A Sphere\n\nThe key to creating a convincing sphere lies in proper point distribution. Unlike naive approaches that create clustering at poles, we use **spherical coordinates** with uniform random sampling:\n\n```javascript\nconst points = [];\nfor (var i = 0; i < 1500; i++) {\n  var vertex = new THREE.Vector3();\n\n  // Uniform random sampling on sphere surface\n  var u = THREE.MathUtils.randFloat(0, 1);\n  var v = THREE.MathUtils.randFloat(0, 1);\n  var theta = 2 * Math.PI * u;           // Azimuthal angle\n  var phi = Math.acos(2 * v - 1);        // Polar angle\n\n  // Convert to Cartesian coordinates\n  vertex.x = 3.5 * Math.sin(phi) * Math.cos(theta);\n  vertex.y = 3.5 * Math.sin(phi) * Math.sin(theta);\n  vertex.z = 3.5 * Math.cos(phi);\n\n  points.push(vertex);\n}\n```\n\nThis approach ensures **uniform distribution** across the sphere surface, avoiding the visual artifacts of simpler random placement methods.\n\n## GLSL Shader\n\nThe pulsating light effect is achieved through custom **vertex and fragment shaders** that run directly on the GPU:\n\n### Shader Uniforms Setup\n\n```javascript\nconst shaderPoint = THREE.ShaderLib.points;\nconst uniforms = THREE.UniformsUtils.clone(shaderPoint.uniforms);\nuniforms.time = { value: 0 };\nuniforms.color = { type: \"v3\", value: colorValue };\n\nconst pMaterial = new THREE.ShaderMaterial({\n  uniforms,\n  transparent: true,\n  depthWrite: false,\n  blending: THREE.AdditiveBlending,  // Creates light emission effect\n  vertexShader,\n  fragmentShader,\n});\n```\n\n### The Shader Pipeline\n\nThis particle system consists of two interconnected shaders:\n\n- **Vertex Shader** (\"vert.glsl\") - Handles particle positioning, sizing, and movement\n- **Fragment Shader** (\"frag.glsl\") - Controls particle appearance, color, and glow effects\n\n### 3D Simplex Noise Implementation\n\nThe vertex shader begins with a complete **Simplex noise** implementation - a sophisticated algorithm for generating natural-looking randomness:\n\n```glsl\nfloat snoise(vec3 v) {\n    // 85 lines of math\n    // Creates smooth, continuous 3D noise\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n```\n\n**Why Simplex Noise?** Unlike basic random functions, Simplex noise provides:\n- **Continuous gradients** - no sudden jumps or artifacts\n- **3D coherence** - neighboring points have similar values\n- **Performance optimization** - faster than Perlin noise\n- **Natural patterns** - mimics organic movement and growth\n\n### Organic Particle Movement\n\nThe main vertex shader transforms each particle's position using time-based trigonometric functions:\n\n```glsl\nvec3 newPos = position;\n\nnewPos.x += sin(time + position.x * position.y) * 0.08;\nnewPos.y += cos(time + position.x * position.y * 1.1) * 0.08;\nnewPos.z += cos(time + position.x * position.y * 1.3) * 0.08;\n```\n\n**Mathematical Breakdown:**\n- **Base oscillation**: \"sin(time)\" and \"cos(time)\" create rhythmic movement\n- **Position coupling**: \"position.x * position.y\" makes each particle's movement unique\n- **Frequency variation**: Multipliers prevent synchronized motion\n- **Amplitude control**: \"0.08\" keeps movement subtle and elegant\n\nThis creates a **Lissajous-like pattern** where each particle follows its own complex orbital path, determined by its starting position.\n\n### Dynamic Particle Sizing\n\nThe most sophisticated aspect is the noise-driven size variation:\n\n```glsl\ngl_PointSize = 50. + snoise(position * 0.05 + vec3(0, 0, vtime * 0.1)) * 50.;\ngl_PointSize *= 0.5;\n```\n\n**Size Calculation Explained:**\n- **Base size**: \"50.\" pixels provides consistent minimum visibility\n- **Noise sampling**: \"snoise(position * 0.05 + ...)\" creates spatial variation\n- **Temporal drift**: \"vec3(0, 0, vtime * 0.1)\" makes noise evolve over time\n- **Amplitude**: \"* 50.\" allows sizes to range from 0 to 100 pixels\n- **Final scaling**: \"* 0.5\" reduces overall scale to 0-50 pixels\n\nThe result is particles that **breathe** - growing and shrinking organically as the noise field evolves through time.\n\n### Time-Based Animation\n\nThe pulsating effect is driven by a time uniform that updates every frame:\n\n```javascript\nconst animate = (time) => {\n  // Update shader time for pulsating effect\n  pMaterial.uniforms.time.value = time * 0.004;\n  \n  // Continue animation loop\n  requestAnimationFrame(animate);\n  renderer.render(scene, camera);\n}\n```\n\nThe **AdditiveBlending** mode creates the characteristic light emission, making particles appear to glow and blend naturally when they overlap.\n\n## Responsive Color System\n\nThe particle system adapts to the user's color mode preference through dynamic uniform updates:\n\n```javascript\n// Real-time color mode detection and adaptation\nif (localStorage.getItem(\"chakra-ui-color-mode\") === \"dark\") {\n  pMaterial.uniforms.color.value = new THREE.Color(0xffffff);  // White particles\n} else {\n  pMaterial.uniforms.color.value = new THREE.Color(0x000000);  // Black particles\n}\n```\n\nThis creates a seamless experience where the 3D scene automatically adapts to the user's interface preferences without requiring page refreshes.\n\n## Smooth Camera Animations\n\nThe initial camera movement uses an **easing function** to create natural motion:\n\n```javascript\nfunction easeOutCirc(x) {\n  return Math.sqrt(1 - Math.pow(x - 1, 4));\n}\n\n// Camera animation during first 100 frames\nif (frame <= 100) {\n  const rotSpeed = -easeOutCirc(frame / 120) * Math.PI * 20;\n  \n  camera.position.x = p.x * Math.cos(rotSpeed) + p.z * Math.sin(rotSpeed);\n  camera.position.z = p.z * Math.cos(rotSpeed) - p.x * Math.sin(rotSpeed);\n  camera.lookAt(target);\n} else {\n  // Switch to user-controlled orbit after animation\n  controls.update();\n}\n```\n\nAfter the initial animation completes, control transitions to **OrbitControls** for user interaction, with automatic rotation enabled.\n\n## Performance Optimizations\n\n### GPU-Accelerated Rendering\n- **ShaderMaterial** for GPU-based calculations\n\n### Efficient Animation Loop\n```javascript\nlet req = null;\nconst animate = (time) => {\n  req = requestAnimationFrame(animate);\n  \n  // Minimal CPU calculations\n  // GPU handles particle transformations\n  \n  renderer.render(scene, camera);\n}\n\n// Proper cleanup\nreturn () => {\n  cancelAnimationFrame(req);\n  renderer.domElement.remove();\n  renderer.dispose();\n}\n```\n\n## Final Product\nHere is the final animation, best viewed in dark mode!\n<hr />\n<voxel-art />","title":"Building Interactive Web Experiences","date":"2025-07-08","excerpt":"Exploring the combination of Three.js, Framer Motion, and React for creating engaging user interfaces","tags":["threejs","framer-motion","webgl","animation"]}},"__N_SSG":true}